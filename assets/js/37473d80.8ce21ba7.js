"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6339],{73032:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>i,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var t=a(87462),s=(a(67294),a(3905));const r={sidebar_position:2},o="High Availability Installation",l={unversionedId:"deploy/replication",id:"deploy/replication",title:"High Availability Installation",description:"If you intend to run Walrus in production, you need to follow the high-avaialbility installation.",source:"@site/docs/deploy/replication.md",sourceDirName:"deploy",slug:"/deploy/replication",permalink:"/docs/deploy/replication",draft:!1,editUrl:"https://github.com/seal-io/docs/edit/main/docs/deploy/replication.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docs",previous:{title:"Standalone Installation",permalink:"/docs/deploy/standalone"},next:{title:"Application Management",permalink:"/docs/category/application-management"}},i={},p=[{value:"Configuring TLS",id:"configuring-tls",level:2},{value:"Default method, using TLS termination",id:"default-method-using-tls-termination",level:3},{value:"Using a Self-Signed Certificate",id:"using-a-self-signed-certificate",level:3},{value:"Use ACME to Generate Trusted Certificate",id:"use-acme-to-generate-trusted-certificate",level:3},{value:"Using a Custom Certificate",id:"using-a-custom-certificate",level:3},{value:"Configuring the Database",id:"configuring-the-database",level:2}],u={toc:p};function c(e){let{components:n,...a}=e;return(0,s.kt)("wrapper",(0,t.Z)({},u,a,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"high-availability-installation"},"High Availability Installation"),(0,s.kt)("p",null,"If you intend to run Walrus in production, you need to follow the high-avaialbility installation."),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Prerequisites:"),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},"An highly-available Kubernetes cluster is required as the runtime cluster."),(0,s.kt)("li",{parentName:"ul"},"Each Kubernetes node should have at least 4 CPU cores and 8GiB memory."),(0,s.kt)("li",{parentName:"ul"},"At least 50GB of free disk space on each Kubernetes node."),(0,s.kt)("li",{parentName:"ul"},"Ports 80 and 443 are opened on the nodes."))),(0,s.kt)("p",null,"You can fill in the following YAML with relevant information and use the ",(0,s.kt)("inlineCode",{parentName:"p"},"kubectl apply")," command to complete the high availability deployment."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'cat <<EOF | kubectl apply -f -\n\n---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: walrus-system\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  namespace: walrus-system\n  name: walrus\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "entrance"\nspec:\n  defaultBackend:\n    service:\n      name: walrus\n      port:\n        number: 80\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  namespace: walrus-system\n  name: walrus\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "configuration"\nstringData:\n  enable_tls: "false"\n  db_driver: "postgres"\n  db_user: "root"\n  db_password: "Root123"\n  db_name: "walrus"\n---\n\n\n# Database\n#\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  namespace: walrus-system\n  name: database-script\ndata:\n  "init.sh": |\n    #!/usr/bin/env bash\n    \n    set -o errexit\n    set -o nounset\n    set -o pipefail\n    \n    if [[ ! -d \\${PGDATA} ]]; then\n      mkdir -p \\${PGDATA}\n      chown 999:999 \\${PGDATA}\n    fi\n\n  "probe.sh": |\n    #!/usr/bin/env bash\n    \n    set -o errexit\n    set -o nounset\n    set -o pipefail\n    \n    psql --no-password --username=\\${POSTGRES_USER} --dbname=\\${POSTGRES_DB} --command="SELECT 1"\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  namespace: walrus-system\n  name: database\nspec:\n  selector:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "database"\n  ports:\n    - name: conn\n      port: 5432\n      targetPort: conn\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  namespace: walrus-system\n  name: database\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "database"\nspec:\n  storageClassName: standard\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 8Gi\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  namespace: walrus-system\n  name: database\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "database"\n    "app.kubernetes.io/name": "postgres"\nspec:\n  strategy:\n    type: Recreate\n  replicas: 1\n  selector:\n    matchLabels:\n      "app.kubernetes.io/part-of": "walrus"\n      "app.kubernetes.io/component": "database"\n      "app.kubernetes.io/name": "postgres"\n  template:\n    metadata:\n      labels:\n        "app.kubernetes.io/part-of": "walrus"\n        "app.kubernetes.io/component": "database"\n        "app.kubernetes.io/name": "postgres"\n    spec:\n      automountServiceAccountToken: false\n      restartPolicy: Always\n      initContainers:\n        - name: init\n          image: postgres:14.8\n          imagePullPolicy: IfNotPresent\n          command:\n            - /script/init.sh\n          env:\n            - name: PGDATA\n              value: /var/lib/postgresql/data/pgdata\n          volumeMounts:\n            - name: script\n              mountPath: /script\n            - name: data\n              mountPath: /var/lib/postgresql/data\n      containers:\n        - name: postgres\n          image: postgres:14.8\n          imagePullPolicy: IfNotPresent\n          resources:\n            limits:\n              cpu: \'4\'\n              memory: \'8Gi\'\n            requests:\n              cpu: \'500m\'\n              memory: \'512Mi\'\n          securityContext:\n            runAsUser: 999\n          ports:\n            - name: conn\n              containerPort: 5432\n          env:\n            - name: POSTGRES_USER\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_user\n            - name: POSTGRES_PASSWORD\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_password\n            - name: POSTGRES_DB\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_name\n            - name: PGDATA\n              value: /var/lib/postgresql/data/pgdata\n          startupProbe:\n            failureThreshold: 10\n            periodSeconds: 5\n            exec:\n              command:\n                - /script/probe.sh\n          readinessProbe:\n            failureThreshold: 3\n            timeoutSeconds: 5\n            periodSeconds: 5\n            exec:\n              command:\n                - /script/probe.sh\n          livenessProbe:\n            failureThreshold: 3\n            timeoutSeconds: 5\n            periodSeconds: 10\n            exec:\n              command:\n                - /script/probe.sh\n          volumeMounts:\n            - name: script\n              mountPath: /script\n            - name: data\n              mountPath: /var/lib/postgresql/data\n      volumes:\n        - name: script\n          configMap:\n            name: database-script\n            defaultMode: 0555\n        - name: data\n          persistentVolumeClaim:\n            claimName: database\n---\n\n\n# Identity Access Manager\n#\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  namespace: walrus-system\n  name: identity-access-manager-script\ndata:\n  "init.sh": |\n    #!/usr/bin/env bash\n    \n    set -o errexit\n    set -o nounset\n    set -o pipefail\n    \n    # validate database\n    set +o errexit\n    while true; do\n      if psql --command="SELECT 1" "\\${DB_SOURCE}" >/dev/null 2>&1; then\n        break\n      fi\n      echo "waiting db to be ready ..."\n      sleep 2s\n    done\n    set -o errexit\n    \n    # mutate app configuration\n    cp -f /conf/app.conf app.conf\n    sed -i \'/^tableNamePrefix =.*/d\' app.conf\n    echo "tableNamePrefix = casdoor_" >>app.conf\n    sed -i \'/^driverName =.*/d\' app.conf\n    echo "driverName = \\"\\${DB_DRIVER}\\"" >>app.conf\n    sed -i \'/^dataSourceName =.*/d\' app.conf\n    echo "dataSourceName = \\"\\${DB_SOURCE}\\"" >>app.conf\n    sed -i \'/^sessionConfig =.*/d\' app.conf\n    echo \'sessionConfig = {"enableSetCookie":true,"cookieName":"casdoor_session_id","cookieLifeTime":3600,"providerConfig":"/var/run/casdoor","gclifetime":3600,"domain":"","secure":false,"disableHTTPOnly":false}\' >>app.conf\n    sed "s#\\${DB_PASSWORD}#***#g" app.conf\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  namespace: walrus-system\n  name: identity-access-manager\nspec:\n  selector:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "identity-access-manager"\n  ports:\n    - name: http\n      port: 8000\n      targetPort: http\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  namespace: walrus-system\n  name: identity-access-manager\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "identity-access-manager"\n    "app.kubernetes.io/name": "casdoor"\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      "app.kubernetes.io/part-of": "walrus"\n      "app.kubernetes.io/component": "identity-access-manager"\n      "app.kubernetes.io/name": "casdoor"\n  template:\n    metadata:\n      labels:\n        "app.kubernetes.io/part-of": "walrus"\n        "app.kubernetes.io/component": "identity-access-manager"\n        "app.kubernetes.io/name": "casdoor"\n    spec:\n      automountServiceAccountToken: false\n      restartPolicy: Always\n      initContainers:\n        - name: init\n          image: sealio/casdoor:v1.344.0-seal.1\n          imagePullPolicy: IfNotPresent\n          workingDir: /tmp/conf\n          command:\n            - /script/init.sh\n          env:\n            - name: DB_DRIVER\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_driver\n            - name: DB_USER\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_user\n            - name: DB_PASSWORD\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_password\n            - name: DB_NAME\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_name\n            - name: DB_SOURCE\n              value: \\$(DB_DRIVER)://\\$(DB_USER):\\$(DB_PASSWORD)@database:5432/\\$(DB_NAME)?sslmode=disable\n          volumeMounts:\n            - name: script\n              mountPath: /script\n            - name: config\n              mountPath: /tmp/conf\n      containers:\n        - name: casdoor\n          image: sealio/casdoor:v1.344.0-seal.1\n          imagePullPolicy: IfNotPresent\n          resources:\n            limits:\n              cpu: \'2\'\n              memory: \'4Gi\'\n            requests:\n              cpu: \'500m\'\n              memory: \'512Mi\'\n          workingDir: /\n          command:\n            - /casdoor\n            - --createDatabase=true\n          ports:\n            - name: http\n              containerPort: 8000\n          startupProbe:\n            failureThreshold: 10\n            periodSeconds: 5\n\n            tcpSocket:\n              port: 8000\n          readinessProbe:\n            failureThreshold: 3\n            timeoutSeconds: 5\n            periodSeconds: 5\n            tcpSocket:\n              port: 8000\n          livenessProbe:\n            failureThreshold: 3\n            timeoutSeconds: 5\n            periodSeconds: 10\n            tcpSocket:\n              port: 8000\n          volumeMounts:\n            - name: config\n              mountPath: /conf\n            - name: data\n              mountPath: /var/run/casdoor\n      volumes:\n        - name: script\n          configMap:\n            name: identity-access-manager-script\n            defaultMode: 0500\n        - name: config\n          emptyDir: { }\n        - name: data\n          emptyDir: { }\n---\n\n\n# Walrus server\n#\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  namespace: walrus-system\n  name: walrus\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  namespace: walrus-system\n  name: walrus\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\nrules:\n  - apiGroups:\n      - "batch"\n    resources:\n      - "jobs"\n    verbs:\n      - "*"\n  - apiGroups:\n      - ""\n    resources:\n      - "secrets"\n      - "pods"\n      - "pods/log"\n      - "events"\n    verbs:\n      - "*"\n  - apiGroups:\n      - "coordination.k8s.io"\n    resources:\n      - "leases"\n    verbs:\n      - "*"\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  namespace: walrus-system\n  name: walrus\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\nsubjects:\n  - kind: ServiceAccount\n    name: walrus\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: Role\n  name: walrus\n---\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  namespace: walrus-system\n  name: walrus\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\nspec:\n  storageClassName: standard\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 500Mi\n---\napiVersion: v1\nkind: Service\nmetadata:\n  namespace: walrus-system\n  name: walrus\nspec:\n  selector:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\n  sessionAffinity: ClientIP\n  ports:\n    - name: http\n      port: 80\n      targetPort: http\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  namespace: walrus-system\n  name: walrus\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\n    "app.kubernetes.io/name": "walrus-server"\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      "app.kubernetes.io/part-of": "walrus"\n      "app.kubernetes.io/component": "walrus"\n      "app.kubernetes.io/name": "walrus-server"\n  template:\n    metadata:\n      labels:\n        "app.kubernetes.io/part-of": "walrus"\n        "app.kubernetes.io/component": "walrus"\n        "app.kubernetes.io/name": "walrus-server"\n    spec:\n      affinity:\n        podAntiAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:\n            - weight: 100\n              podAffinityTerm:\n                topologyKey: "kubernetes.io/hostname"\n                labelSelector:\n                  matchExpressions:\n                    - key: "app.kubernetes.io/component"\n                      operator: In\n                      values:\n                        - "walrus"\n                    - key: "app.kubernetes.io/part-of"\n                      operator: In\n                      values:\n                        - "walrus"\n                    - key: "app.kubernetes.io/name"\n                      operator: In\n                      values:\n                        - "walrus-server"\n      restartPolicy: Always\n      serviceAccountName: walrus\n      containers:\n        - name: walrus-server\n          image: sealio/walrus:v0.3.0\n          imagePullPolicy: Always\n          resources:\n            limits:\n              cpu: \'4\'\n              memory: \'8Gi\'\n            requests:\n              cpu: \'500m\'\n              memory: \'512Mi\'\n          env:\n            - name: DB_DRIVER\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_driver\n            - name: DB_USER\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_user\n            - name: DB_PASSWORD\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_password\n            - name: DB_NAME\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: db_name\n            - name: SERVER_ENABLE_TLS\n              valueFrom:\n                secretKeyRef:\n                  name: walrus\n                  key: enable_tls\n            - name: SERVER_DATA_SOURCE_ADDRESS\n              value: \\$(DB_DRIVER)://\\$(DB_USER):\\$(DB_PASSWORD)@database:5432/\\$(DB_NAME)?sslmode=disable\n            - name: SERVER_CASDOOR_SERVER\n              value: http://identity-access-manager:8000\n          ports:\n            - name: http\n              containerPort: 80\n            - name: https\n              containerPort: 443\n          startupProbe:\n            failureThreshold: 10\n            periodSeconds: 5\n            httpGet:\n              port: 80\n              path: /readyz\n          readinessProbe:\n            failureThreshold: 3\n            timeoutSeconds: 5\n            periodSeconds: 5\n            httpGet:\n              port: 80\n              path: /readyz\n          livenessProbe:\n            failureThreshold: 10\n            timeoutSeconds: 5\n            periodSeconds: 10\n            httpGet:\n              port: 80\n              path: /livez\n          volumeMounts:\n            - name: custom-tls\n              mountPath: /etc/walrus/ssl\n            - name: data\n              mountPath: /var/run/walrus\n      volumes:\n        - name: custom-tls\n          secret:\n            secretName: walrus-custom-tls\n            optional: true\n        - name: data\n          persistentVolumeClaim:\n            claimName: walrus\n\nEOF\n')),(0,s.kt)("h2",{id:"configuring-tls"},"Configuring TLS"),(0,s.kt)("h3",{id:"default-method-using-tls-termination"},"Default method, using TLS termination"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/TLS_termination_proxy"},"TLS termination")," is usually performed by a reverse proxy service, that is, the Ingress Service of the cluster provides the TLS service."),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note:"),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},"The reverse proxy service can use HTTP requests to Walrus, and you should set Walrus's session cookie ",(0,s.kt)("inlineCode",{parentName:"li"},"walrus_session")," to ",(0,s.kt)("inlineCode",{parentName:"li"},"Secure: true")," to prevent man-in-the-middle attacks."))),(0,s.kt)("h3",{id:"using-a-self-signed-certificate"},"Using a Self-Signed Certificate"),(0,s.kt)("p",null,"Walrus can issue a self-signed HTTPS certificate for test purposes."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl apply")," to add a NodePort type Service.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'cat <<EOF | kubectl apply -f -\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  namespace: walrus-system\n  name: walrus\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "entrance"\nspec:\n  selector:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\n  sessionAffinity: ClientIP\n  type: NodePort\n  ports:\n    - name: http\n      port: 80\n      targetPort: http\n    - name: https\n      port: 443\n      targetPort: https\n\nEOF\n')),(0,s.kt)("ol",{start:2},(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl patch")," to modify the TLS option in Secret.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'kubectl -n walrus-system patch secret walrus --type=\'json\' -p=\'[{"op":"replace","path":"/data/enable_tls","value":"dHJ1ZQ=="}]\'\n')),(0,s.kt)("ol",{start:3},(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl delete")," to delete Ingress.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl -n walrus-system delete ingress walrus\n")),(0,s.kt)("ol",{start:4},(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl rollout")," to restart Walrus.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl -n walrus-system rollout restart deployment/walrus\n")),(0,s.kt)("h3",{id:"use-acme-to-generate-trusted-certificate"},"Use ",(0,s.kt)("a",{parentName:"h3",href:"https://letsencrypt.org/docs/challenge-types"},"ACME")," to Generate Trusted Certificate"),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note:"),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},'If the cluster can perform ACME challenges at the Ingress Controller level via CertManager, please refer to "Using TLS Termination".'))),(0,s.kt)("p",null,"You can use Let's Encrypt to issue a 90-day HTTPS certificate. The renewal of this certificate is performed by Walrus automatically."),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Prerequisites:"),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},"The cluster should support the LoadBalancer type of Service."),(0,s.kt)("li",{parentName:"ul"},"Provide a domain name, for example, ",(0,s.kt)("inlineCode",{parentName:"li"},"walrus.mydomain.com"),"."))),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl apply")," to add a LoadBalancer type of Service.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'cat <<EOF | kubectl apply -f -\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  namespace: walrus-system\n  name: walrus\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "entrance"\nspec:\n  selector:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "walrus"\n  sessionAffinity: ClientIP\n  type: LoadBalancer\n  ports:\n    - name: http\n      port: 80\n      targetPort: http\n    - name: https\n      port: 443\n      targetPort: https\n\nEOF\n')),(0,s.kt)("ol",{start:2},(0,s.kt)("li",{parentName:"ol"},"Use the ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl get")," command to wait for the LoadBalancer type of service to get an Ingress IP.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"until [[ -n $(kubectl -n walrus-system get service walrus --template=\"{{range .status.loadBalancer.ingress}}{{.ip}}{{end}}\") ]]; do :; done && \\\n  kubectl get service walrus -o=jsonpath='{.status.loadBalancer.ingress[0].ip}'\n\n")),(0,s.kt)("ol",{start:3},(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"On the DNS configuration panel, add the above A Record pointing to the output IP address.")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Use ",(0,s.kt)("inlineCode",{parentName:"p"},"kubectl patch")," to modify the TLS option in Secret."))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'kubectl -n walrus-system patch secret walrus --type=\'json\' -p=\'[{"op":"replace","path":"/data/enable_tls","value":"dHJ1ZQ=="}]\'\n')),(0,s.kt)("ol",{start:5},(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl delete")," to delete Ingress.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl -n walrus-system delete ingress walrus\n")),(0,s.kt)("ol",{start:6},(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl patch")," to modify the environment variables of Walrus to respond to the ACME challenge.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'export DNS_NAME=""; kubectl -n walrus-system patch deployment walrus --type json -p "[{\\"op\\":\\"add\\",\\"path\\":\\"/spec/template/spec/containers/0/env/-\\",\\"value\\":{\\"name\\":\\"SERVER_TLS_AUTO_CERT_DOMAINS\\",\\"value\\":\\"${DNS_NAME}\\"}}]"\n')),(0,s.kt)("h3",{id:"using-a-custom-certificate"},"Using a Custom Certificate"),(0,s.kt)("p",null,"A custom certificate is an HTTPS  certificate issued by a certificate authority."),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Prerequisites:"),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},"Get the content of the HTTPS service private key PEM file, note it as PRIVATE_KEY_FILE_CONTENT."),(0,s.kt)("li",{parentName:"ul"},"Get the content of the HTTPS service certificate (chain) PEM file, note it as CERT_FILE_CONTENT."),(0,s.kt)("li",{parentName:"ul"},"If there is a (non-publicly trusted) CA certificate, get the corresponding PEM file content and concatenate it to CERT_FILE_CONTENT."))),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Use the ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl apply")," command to add a Secret with custom certificate content.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'export PRIVATE_KEY_FILE_CONTENT=""; export CERT_FILE_CONTENT=""; cat <<EOF | kubectl apply -f -\n\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  namespace: walrus-system\n  name: walrus-custom-tls\n  labels:\n    "app.kubernetes.io/part-of": "walrus"\n    "app.kubernetes.io/component": "configuration"\ntype: kubernetes.io/tls\nstringData:\n  "tls.crt": "\\${CERT_FILE_CONTENT}"\n  "tls.key": "\\${PRIVATE_KEY_FILE_CONTENT}"\n\nEOF\n')),(0,s.kt)("ol",{start:2},(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl patch")," to modify the TLS option in Secret.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'kubectl -n walrus-system patch secret walrus --type=\'json\' -p=\'[{"op":"replace","path":"/data/enable_tls","value":"dHJ1ZQ=="}]\'\n')),(0,s.kt)("ol",{start:3},(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl delete")," to delete Ingress.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl -n walrus-system delete ingress walrus\n")),(0,s.kt)("ol",{start:4},(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl patch")," to modify the environment variables of Walrus to enable the custom certificate.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'kubectl -n walrus-system patch deployment walrus --type json \\\n-p \'[{"op":"add","path":"/spec/template/spec/containers/0/env/-","value":{"name":"SERVER_TLS_CERT_FILE","value":"/etc/walrus/ssl/tls.crt"}},{"op":"add","path":"/spec/template/spec/containers/0/env/-","value":{"name":"SERVER_TLS_PRIVATE_KEY_FILE","value":"/etc/walrus/ssl/tls.key"}}]\'\n')),(0,s.kt)("h2",{id:"configuring-the-database"},"Configuring the Database"),(0,s.kt)("p",null,"Walrus relies on ",(0,s.kt)("a",{parentName:"p",href:"https://www.postgresql.org/"},"PostgreSQL")," relational database for data storage."),(0,s.kt)("p",null,"By default, Walrus will run an instance of PostgresSQL within the running container, which is can lead to potential data loss. In an HA install, users must provide an external PostgreSQL instance."),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note:"),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},"The following commands override previous variables by repeatedly adding duplicate environment variables, which may receive a warning from Kubernetes."))),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl patch")," to modify the environment variables of IdentifyAccessManager to connect to the external data source.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'export DB_SOURCE=""; kubectl -n walrus-system patch deployment identity-access-manager --type json \\\n-p "[{\\"op\\":\\"add\\",\\"path\\":\\"/spec/template/spec/initContainers/0/env/-\\",\\"value\\":{\\"name\\":\\"DB_SOURCE\\",\\"value\\":\\"${DB_SOURCE}\\"}}]"\n')),(0,s.kt)("ol",{start:2},(0,s.kt)("li",{parentName:"ol"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"kubectl patch")," to modify the environment variables of Walrus to connect to the external data source.")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'export DB_SOURCE=""; kubectl -n walrus-system patch deployment walrus --type json \\\n-p "[{\\"op\\":\\"add\\",\\"path\\":\\"/spec/template/spec/containers/0/env/-\\",\\"value\\":{\\"name\\":\\"SERVER_DATA_SOURCE_ADDRESS\\",\\"value\\":\\"${DB_SOURCE}\\"}}]"\n')))}c.isMDXComponent=!0}}]);